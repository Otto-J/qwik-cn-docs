---
title: 请求处理 | 高级
description: 如何在 Qwik City 中处理请求，包括 REST 端点和中间件。
contributors:
  - adamdbradley
  - manucorporat
  - mhevery
  - hamatoyogi
---

# 请求处理

`src/routes` 目录中的每个 `layout.ts` 和 `index.ts` 文件都可以访问当前的 HTTP 请求、响应和 URL。这使您可以检索和修改数据，甚至可以响应自定义内容。

Qwik City 实现了一个基于 `src/routes` 目录层次结构的中间件系统。中间件系统用于处理 HTTP 请求和响应，并可用于页面、布局和[端点](/docs/(qwikcity)/endpoints/index.mdx)。

每个路由都可以添加 HTTP 请求和响应处理程序，允许开发人员检索和修改数据。这些处理程序也可以被[端点](/docs/(qwikcity)/endpoints/index.mdx)使用，端点只响应数据，而不是页面的 HTML。

这个功能使您能够处理任何请求事件，在渲染组件之前对请求管道产生副作用，并响应自定义内容。它适用于页面、布局和端点路由，但不适用于常规组件。

## 请求和响应处理程序

在页面、布局和[端点](/docs/(qwikcity)/endpoints/index.mdx)上，我们可以通过实现请求处理程序函数（如 `onGet`、`onPost`、`onPut` 等）来访问请求数据。这些函数根据用于此路由的[HTTP 方法](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)执行。

此外，可以使用 `onRequest` 函数来处理任何请求方法，而不是特定的请求方法，以[中间件](/docs/(qwikcity)/middleware/index.mdx)的形式。例如，如果同时提供了 `onGet` 和 `onRequest`，对于 `GET` 请求，将调用 `onGet`。然而，在这种情况下，如果收到一个 `POST` 请求方法，则会调用 `onRequest` 处理程序，因为没有提供 `onPost`。
`onRequest` 是一个捕获所有没有特定方法的请求方法的方法。

```tsx
import type { RequestHandler } from '@builder.io/qwik-city';

export const onGet: RequestHandler<ProductData> = async ({ params }) => {
  // 在这里放置您的数据库访问（为简单起见，硬编码数据）
  return {
    skuId: params.skuId,
    price: 123.45,
    description: `Description for ${params.skuId}`,
  };
};
```

## 请求事件

请求处理程序函数接收一个 `RequestEvent` 参数，该参数具有以下属性：

| 字段       | 描述                                                                 |
| ---------- | -------------------------------------------------------------------- |
| `request`  | 请求对象                                                             |
| `response` | 响应对象，可用于设置响应的 `headers` 和 `status`                      |
| `url`      | URL，包括 `pathname`、`hostname` 等                                    |
| `next`     | 下一个中间件函数                                                     |
| `abort`    | 请求中止函数                                                         |
| `params`   | URL 中的自定义用户参数                                                |
| `cookie`   | 获取和设置 cookie                                                    |
| `platform` | 平台数据对象（对 Cloudflare、Netlify 等很有用）                        |

### Cookie

```tsx
interface Cookie {
  get: (key: string) => CookieValue | null;
  set: (key: string, value: string | number | Record<string, any>, options?: CookieOptions) => void;
  delete: (key: string) => void;
  has: (key: string) => boolean;
}
```

**get**
接受一个字符串作为 cookie 名称，并返回 `CookieValue`，如果存在则返回，否则返回 null。

```tsx
interface CookieValue {
  value: string;
  json: <T = unknown>() => T;
  number: () => number;
}
```

Cookie 值是一个简单的记录，包含三个字段：

1. `value`：包含 cookie 值的字符串
2. `json()`：对值运行 `JSON.parse()` 并返回结果
3. `number()`：对值运行 `Number()` 并返回结果

**getAll**
返回一个包含所有 cookie 的对象（如果有）。_如果 cookie 的名称未知且必须通过解析来获取，则有时需要使用此方法。_

**set**
接受一个键和值，并创建一个将附加到响应的标头。值可以是 `string | number | Record<string, any>`

作为第三个参数，您可以选择提供一个 `CookieOptions` 记录以设置其他字段。

```tsx
export interface CookieOptions {
  domain?: string;
  expires?: Date | string;
  httpOnly?: boolean;
  maxAge?: number | [number, 'seconds' | 'minutes' | 'hours' | 'days' | 'weeks'];
  path?: string;
  sameSite?: 'lax' | 'none' | 'strict';
  secure?: boolean;
}
```

有关这些属性及其值的更多信息，请参阅[MDN 上关于 Set-Cookie 标头的文章](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#attributes)。

**delete**
向 cookie 添加一个具有提供的键的标头。新标头的 `expires` 字段中将有一个过期日期，告诉浏览器将其删除。

```tsx
cookie.delete('my-cookie');
// 等同于
cookie.set('my-cookie', 'deleted', new Date(0));
```

可选地，您可以在删除 cookie 时设置路径和/或域。如果您的 cookie 是使用路径/域创建的，则必须设置这些字段才能使删除生效。

```tsx
cookie.delete('my-cookie', { domain: 'https://qwik.builder.io', path: '/docs/' });
```

**has**
一个方便的方法，根据 cookie 中是否存在提供的键返回 true 或 false。

```tsx
cookie.has('my-cookie');
```
