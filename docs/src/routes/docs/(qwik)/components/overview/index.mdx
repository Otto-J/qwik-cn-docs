---
title: Overview | Components
contributors:
  - RATIU5
  - leifermendez
  - manucorporat
  - adamdbradley
  - cunzaizhuyi
  - shairez
  - the-r3aper7
  - zanettin
  - Craiqser
  - steve8708
  - mforncro
  - georgeiliadis91
  - leader22
  - almilo
  - estherbrunner
  - kumarasinghe
  - mhevery
  - AnthonyPAlicea
  - khalilou88
  - n8sabes
  - fabian-hiller
  - gioboa
  - mrhoodz
  - eecopa
  - drumnistnakano
  - maiieul
  - wmertens
  - aendel
  - jemsco
updated_at: '2023-12-14T18:38:38Z'
created_at: '2023-03-20T23:45:13Z'
---

import CodeSandbox from '../../../../../components/code-sandbox/index.tsx';

# Components

组件是 Qwik 应用程序的基本构建块。它们是可重用的代码片段，可用于构建 UI。

Qwik 组件的独特之处在于：

- Qwik 组件会自动被 [优化器](../../advanced/optimizer/index.mdx) 分解成惰性加载的块。
- 它们是 [可恢复的](../../concepts/resumable/index.mdx)（组件可以在服务器上创建，并在客户端继续执行）。
- 它们是 [响应式的](../../concepts/reactivity/index.mdx) 并且独立于页面上的其他组件进行渲染。参见 [渲染](../../components/rendering/index.mdx)。

## `component$()`

Qwik 组件是一个返回 JSX 的函数，并包装在 `component$` 调用中。

<CodeSandbox src="/src/routes/demo/component/simple/index.tsx" style={{ height: '3em' }}>
```tsx /component$/
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return <div>Hello World!</div>;
});
```
</CodeSandbox>

> `component$` 函数（以 `$` 结尾）使优化器能够将组件拆分为单独的块。
这允许每个块根据需要独立加载，而不是在加载父组件时加载所有组件。
> 注意：routes 文件夹中的 index.tsx、layout.tsx、root.tsx 以及所有入口文件都需要 **export default**。对于其他组件，您可以使用 export const 和 export function。

### 组件组合

组件可以组合在一起以创建更复杂的组件。


<CodeSandbox src="/src/routes/demo/component/child/index.tsx" style={{ height: '6em' }}>
```tsx {7}
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return (
    <>
      <p>Parent Text</p>
      <Child />
    </>
  );
});

const Child = component$(() => {
  return <p>Child Text</p>;
});
```
</CodeSandbox>

> 请注意，由于 `$` 符号的存在，Qwik 组件已经实现了惰性加载。这意味着您不需要手动动态导入子组件，Qwik 会为您完成。

### 计数器示例

一个稍微复杂一点的计数器示例。

<CodeSandbox src="/src/routes/demo/state/counter/index.tsx" style={{ height: '6em' }}>
```tsx
import { component$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const count = useSignal(0);

  return (
    <>
      <p>Count: {count.value}</p>
      <button onClick$={() => count.value++}>Increment</button>
    </>
  );
});
```
</CodeSandbox>

## Props

Props 用于将数据从父组件传递到子组件。通过 props 传递的数据可以通过 `component$` 函数的 `props` 参数访问。

Props 是浅不可变的，这意味着基本数据类型（字符串、数字、布尔值）一旦传递就不能更改。但是，引用类型（对象、数组、函数）的内部元素可以更改，尽管引用本身是不可变的。

要从子组件更改父组件中的基本 props 数据，请使用信号。当在子组件中本地更新数据时，不需要使用信号，只需解构 props 并使用这些值定义新的局部变量。

以下两个示例展示了一个名为 `Item` 的组件，它声明了可选的 `name`、`quantity`、`description` 和 `price` props。

在第一个示例中，基本数据类型通过 props 传递。`price` prop 作为信号传递，可以从父组件更改。`quantity` 作为数值传递，用于在 `Item` 中定义一个新的信号，该信号可以在本地进行响应式更新。或者，如果 `quantity` 不需要响应式，则可以将其定义为普通变量而不是信号。

<CodeSandbox src="/src/routes/demo/component/primitive-props/index.tsx" style={{ height: '10em' }}>
```tsx {3-8, 27} /ItemProps/
import { component$, useSignal } from "@builder.io/qwik";
import type { Signal } from "@builder.io/qwik";

interface ItemProps {
  name?: string;
  quantity?: number;
  description?: string;
  price?: Signal<number>;
}

export const Item = component$<ItemProps>((props) => {
  const localQuantity = useSignal(props.quantity);

  return (
    <ul>
      <li>name: {props.name}</li>
      <li>quantity: {localQuantity}</li>
      <li>description: {props.description}</li>
      <li>price: {props.price}</li>
    </ul>
  );
});

export default component$(() => {
  const price = useSignal(9.99);

  return (
    <>
      <h1>Props</h1>
      <Item name="hammer" price={price} quantity={5} />
    </>
  );
});

```
</CodeSandbox>

在第二个示例中，props 作为包含数据的单个 `details` 对象传递，而不是单独的基本值。这允许在不使用信号的情况下对内部数据进行变异。但是，存储数据的 `details` 对象仍然是不可变的，一旦传递就不能更改。

<CodeSandbox src="/src/routes/demo/component/reference-props/index.tsx" style={{ height: '10em' }}>
```tsx {3-8, 27} /ItemProps/
import { component$ } from "@builder.io/qwik";

interface ItemProps {
  details: {
    name?: string;
    quantity?: number;
    description?: string;
    price?: number;
  };
}

export const Item = component$((props: ItemProps) => {
  props.details.price = 4.99;

  return (
    <ul>
      <li>name: {props.details.name}</li>
      <li>quantity: {props.details.quantity}</li>
      <li>description: {props.details.description}</li>
      <li>price: {props.details.price}</li>
    </ul>
  );
});

export default component$(() => {
  return (
    <Item
      details={{ name: "hammer", quantity: 5, description: "", price: 9.99 }}
    />
  );
});

```
</CodeSandbox>

> 在上面的示例中，我们使用 `component$<ItemProps>` 来为 props 提供显式类型。这是可选的，但它允许 TypeScript 编译器检查 props 是否被正确使用。

### 默认 props

您可以使用 props 的解构模式来提供默认值。

```tsx
interface Props {
  enabled?: boolean;
  placeholder?: string;
}

// 我们可以使用 JS 的 props 解构来提供默认值。
export default component$<Props>(({enabled = true, placeholder = ''}) => {
  return (
    <input disabled={!enabled} placeholder={placeholder} />
  );
});
```

## 响应式渲染

Qwik 组件是响应式的。这意味着它们会在状态发生变化时自动更新。更新有两种类型：

1. 状态绑定到 DOM 文本或属性。此类更改通常会直接更新 DOM，并且不需要重新执行组件函数。
2. 状态导致 DOM 结构发生变化（元素被创建或删除）。此类更改需要重新执行组件函数。

需要注意的是，当状态发生变化时，您的组件函数可能会执行零次或多次，具体取决于状态绑定到的内容。因此，该函数应该是幂等的，您不应该依赖于它执行的次数。

状态变化会导致组件失效。当组件失效时，它们会被添加到失效队列中，该队列会在下一个 `requestAnimationFrame` 上被刷新（渲染）。这充当组件渲染的合并形式。

## 获取 DOM 元素

使用 `ref` 获取 DOM 元素。创建一个信号来存储 DOM 元素。然后将信号传递给 JSX 的 `ref` 属性。

> 获取 DOM 元素的引用对于计算元素大小 (`getBoundingClientRect`)、计算样式、初始化 WebGL 画布，甚至连接直接与 DOM 元素交互的第三方库很有用。

<CodeSandbox src="/src/routes/demo/component/ref/index.tsx" style={{ height: '10em' }}>
```tsx /const outputRef = useSignal<Element>();/ /ref={outputRef}/
import { component$, useVisibleTask$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const width = useSignal(0);
  const height = useSignal(0);
  const outputRef = useSignal<Element>();

  useVisibleTask$(() => {
    if (outputRef.value) {
      const rect = outputRef.value.getBoundingClientRect();
      width.value = Math.round(rect.width);
      height.value = Math.round(rect.height);
    }
  });

  return (
    <section>
      <article
        ref={outputRef}
        style={{ border: '1px solid red', width: '100px' }}
      >
        Change text value here to stretch the box.
      </article>
      <p>
        The above red box is {height.value} pixels high and {width.value}{' '}
        pixels wide.
      </p>
    </section>
  );
});
```
</CodeSandbox>

## 通过 `id` 在服务器和客户端环境中访问元素

在服务器和客户端环境中，有时需要通过 `id` 访问元素。使用 `useId()` 函数获取当前组件的唯一标识符，该标识符在服务器端渲染 (SSR) 和客户端操作中保持一致。当服务器端渲染的组件需要客户端脚本时，这一点至关重要，例如：

1. **动画引擎**
2. **辅助功能增强**
3. **其他客户端库**

在多个片段同时运行的微前端设置中，`useId()` 确保了跨执行环境的唯一且一致的 ID，消除了冲突。

<CodeSandbox src="/src/routes/demo/component/useId/index.tsx" style={{ height: '10em' }}>
```tsx /const outputRef = useSignal<Element>();/ /ref={outputRef}/
import {
  component$,
  useId,
  useSignal,
  useVisibleTask$,
} from '@builder.io/qwik';

export default component$(() => {
  const elemIdSignal = useSignal<string | null>(null);
  const id = useId();
  const elemId = `${id}-example`;
  console.log('server-side id:', elemId);

  useVisibleTask$(() => {
    const elem = document.getElementById(elemId);
    elemIdSignal.value = elem?.getAttribute('id') || null;
    console.log('client-side id:', elemIdSignal.value);
  });

  return (
    <section>
      <div id={elemId}>
        Both server-side and client-side console should match this id:
        <br />
        <b>{elemIdSignal.value || null}</b>
      </div>
    </section>
  );
});
```
</CodeSandbox>

## 延迟加载

组件在为捆绑目的打破父子关系时也起着重要作用。

```tsx
export const Child = () => <span>child</span>;

const Parent = () => (
  <section>
    <Child />
  </section>
);
```

在上面的示例中，引用 `Parent` 组件意味着对 `Child` 组件的传递引用。当捆绑器创建块时，对 `Parent` 的引用也需要捆绑 `Child`。（`Parent` 在内部引用 `Child`。）这些传递依赖关系是一个问题，因为它意味着对根组件的引用将传递地引用应用程序的其余部分——这是 Qwik 试图明确避免的事情。

为了避免上述问题，我们不直接引用组件，而是引用延迟包装器。这是由 `component$()` 函数自动创建的。

<CodeSandbox src="/src/routes/demo/component/lazy/index.tsx" style={{ height: '4em' }} sandbox={false}>
```tsx
import { component$ } from '@builder.io/qwik';

export const Child = component$(() => {
  return <p>child</p>;
});

export const Parent = component$(() => {
  return (
    <section>
      <Child />
    </section>
  );
});

export default Parent;
```
</CodeSandbox>

在上面的示例中，优化器将上述代码转换为：

```tsx
const Child = componentQrl(qrl('./chunk-a', 'Child_onMount'));
const Parent = componentQrl(qrl('./chunk-b', 'Parent_onMount'));
const Parent_onMount = () => qrl('./chunk-c', 'Parent_onRender');
const Parent_onRender = () => (
  <section>
    <Child />
  </section>
);
```

> **注意**
> 为了简单起见，并非所有转换都显示出来；所有生成的符号都保存在同一个文件中，以简洁起见。

请注意，在优化器转换代码后，`Parent` 不再直接引用 `Child`。这一点很重要，因为它允许捆绑器（和树摇器）自由地将符号移动到不同的块中，而不会将应用程序的其余部分也拉进来。

那么，当 `Parent` 组件需要渲染 `Child` 组件，但 `Child` 组件尚未下载时会发生什么？首先，`Parent` 组件会像这样渲染它的 DOM。

```html
<main>
  <section>
    <!--qv--><!--/qv-->
  </section>
</main>
```

如您在上面的示例中所见，`<!--qv-->` 充当 `Child` 组件延迟加载后将被插入的标记。

## 内联组件

除了具有所有延迟加载属性的标准 `component$()` 之外，Qwik 还支持轻量级（内联）组件，这些组件的行为更像传统框架中的组件。

<CodeSandbox src="/src/routes/demo/component/inline-child/index.tsx" style={{height: '4em'}}>
```tsx
import { component$ } from '@builder.io/qwik';

// 内联组件：使用标准函数声明。
export const MyButton = (props: { text: string }) => {
  return <button>{props.text}</button>;
};

// 组件：使用 `component$()` 声明。
export default component$(() => {
  return (
    <p>
      Some text:
      <MyButton text="Click me" />
    </p>
  );
});
```
</CodeSandbox>

在上面的示例中，`MyButton` 是一个内联组件。
与标准 `component$()` 不同，内联组件不能单独延迟加载；相反，它们会与它们的父组件捆绑在一起。在本例中：

- `MyButton` 将与 `default` 组件捆绑在一起。
- 每当渲染 `default` 时，它也会保证渲染 `MyButton`。

您可以将内联组件视为内联到它们被实例化的组件中。

### 限制
内联组件具有一些标准 `component$()` 不具备的限制。内联组件：
- 不能使用 `use*` 方法，例如 `useSignal` 或 `useStore`。
- 不能使用 `<Slot>` 投射内容。

顾名思义，内联组件最适合谨慎地用于轻量级标记片段，因为它们提供了与父组件捆绑在一起的便利性。

## 多态组件

当您想要根据道具输出不同类型的元素，但默认使用 `<div>` 时，您可以使用类似以下代码：

```tsx
const Poly = component$(
  <C extends string | FunctionComponent = 'div'>({
    as,
    ...props
  }: { as?: C } & PropsOf<string extends C ? 'div' : C>) => {
    const Cmp = as || 'div';
    return (
      <Cmp {...props}>
        <Slot />
      </Cmp>
    );
  }
);

export const TestComponent = component$(() => {
  // These all work with correct types
  return (
    <>
      <Poly>Hello from a div</Poly>
      <Poly as="a" href="/blog">
        Blog
      </Poly>
      <Poly as="input" onInput$={(ev, el) => console.log(el.value)} />
      <Poly as={OtherComponent} someProp />
    </>
  );
});
```

Note the `string extends C`, this is only true when TypeScript cannot infer the type from the `as` prop allowing you to specify the default type.

## API Overview

### State

- [`useSignal(initialState)`](../state/index.mdx#usesignal) - creates a reactive value
- [`useStore(initialStateObject)`](../state/index.mdx#usestore) - creates a reactive object that can be used to store state
- [`createContextId(contextName)`](../context/index.mdx#createcontext) - creates a context reference
- [`useContextProvider()`](../context/index.mdx#usecontextprovider) - provides a value to a given context
- [`useContext()`](../context/index.mdx#usecontext) - reads the value of the current context

### Styles

- [`useStylesScoped$()`](../styles/index.mdx#usestylesscoped) - appends scoped styles to the component
- [`useStyles$()`](../styles/index.mdx#usestyles) - appends unscoped styles to the component

### Events

- [`useOn()`](../events/index.mdx#useonwindowdocument-hook) - appends a listener to the current component programmatically
- [`useOnWindow()`](../events/index.mdx#useonwindowdocument-hook) - appends a listener to the window object programmatically
- [`useOnDocument()`](../events/index.mdx#useonwindowdocument-hook) - appends a listener to the document object programmatically

### Tasks/Lifecycle

- [`useTask$()`](../tasks/index.mdx#usetask) - defines a callback that will be called before render and/or when a watched store changes
- [`useVisibleTask$()`](../tasks/index.mdx#usevisibletask) - defines a callback that will be called after rendering in the client only (browser)
- [`useResource$()`](../state/index.mdx#useresource) - creates a resource to asynchronously load data

### Other

- [`$()`](../../advanced/qrl/index.mdx) - creates a QRL
- [`noSerialize()`](/docs/components/state/#noserialize)
- `useErrorBoundary()`

### Components

- [`<Slot>`](../slots/index.mdx) - declares a content projection slot
- `<SSRStreamBlock>` - declares a stream block
- `<SSRStream>` - declares a stream
- `<Fragment>` - declares a JSX fragment

## See Also

- [Inline components](../overview/index.mdx#inline-components)
