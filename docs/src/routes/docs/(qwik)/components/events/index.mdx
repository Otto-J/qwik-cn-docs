---
title: 事件 | Components
contributors:
  - voluntadpear
  - the-r3aper7
  - RATIU5
  - manucorporat
  - nnelgxorz
  - adamdbradley
  - hamatoyogi
  - fleish80
  - cunzaizhuyi
  - Pika-Pool
  - mhevery
  - AnthonyPAlicea
  - amatiash
  - harishkrishnan24
  - fabian-hiller
  - igorbabko
  - mrhoodz
  - julianobrasil
  - maiieul
  - Balastrong
  - Jemsco
updated_at: '2024-01-09T20:55:11Z'
created_at: '2023-03-20T23:45:13Z'
---

import CodeSandbox from '../../../../../components/code-sandbox/index.tsx';

# 事件

要使 Web 应用程序具有交互性，需要一种方式来响应用户事件。这是通过在 JSX 模板中注册回调函数来完成的。事件处理程序是使用 `on{EventName}$` 属性注册的。例如，`onClick$` 属性用于监听 `click` 事件。

```tsx /onClick$/
<button onClick$={() => alert('CLICKED!')}>click me!</button>
```

## 内链事件

在下面的案例，`<button>` 元素的 `onClick$` 属性用于告诉 Qwik，每当 `<button>` 触发 `click` 事件时，都应执行回调 `() => store.count++`。

<CodeSandbox src="/src/routes/demo/state/counter-signal/index.tsx" style={{ height: '6em' }}>
```tsx {7} /onClick$/
import { component$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const count = useSignal(0);

  return (
    <button onClick$={() => count.value++}>
      Increment {count.value}
    </button>
  );
});
```
</CodeSandbox>

你也可以使用 `bind:propertyName` 来方便地实现信号和输入元素之间的[双向绑定](/docs/(qwik)/components/rendering/index.mdx#bind-attribute)。

注意 `onClick$` 以 [`$`](/docs/(qwik)/advanced/dollar/index.mdx) 结尾。这既是对 优化器 和开发者的提示，表明在这个位置发生了特殊的转换。`$` 后缀的存在意味着这里是一个懒加载边界。与 `click` 处理程序相关联的代码直到用户激活点击事件之前不会被加载到 JavaScript 虚拟机（VM）中。然而，为了避免在第一次交互时的延迟，它会被急切地加载到浏览器缓存中。

> 在实际应用中，监听器可能会引用复杂的代码。通过创建一个懒加载边界（带有 `$`），Qwik 可以对点击监听器后面的所有代码进行摇树优化，并延迟其加载直到用户点击按钮。

## 重用事件处理程序

要为多个元素或事件重用相同的事件处理程序，你必须将事件处理程序包装进由 `@builder.io/qwik` 导出的 `$()` 函数中。这会将其转换成一个 [`QRL`](/docs/advanced/qrl/)。

<CodeSandbox src="/src/routes/demo/events/extracted-handler/index.tsx" style={{ height: '6em' }}>
```tsx {5} /increment/#a
import { component$, useSignal, $ } from '@builder.io/qwik';

export default component$(() => {
  const count = useSignal(0);
  const increment = $(() => count.value++);
  return (
    <>
      <button onClick$={increment}>Increment</button>
      <p>Count: {count.value}</p>
    </>
  );
});
```
</CodeSandbox>


> **注意：**如果你提取了事件处理程序，必须手动将其包装在 `$(...handler...)` 中。这确保了它是懒加载附加的。

## 多个事件处理程序

要为同一个事件注册多个事件处理程序，你可以将事件处理程序的数组传递给 `on{EventName}$` 属性。

```tsx /onClick$/
import { component$, useSignal, $ } from '@builder.io/qwik';

export default component$(() => {
  const count = useSignal(0);
  const print = $((ev) => console.log('CLICKED!', ev));
  const increment = $(() => count.value++);

  // The button when clicked will print "CLICKED!" to the console, increment the count and send an event to Google Analytics.
  return (
    <button
      onClick$={[print, increment, $(() => {
        ga.send('click', { label: 'increment' });
      })]}
    >
      Count: {count.value}
    </button>
  );
});
```

## 事件对象

事件处理程序的第一个参数是 [`Event`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22path%22%3A%22%2FUsers%2Fotto%2Fmycode%2Fqwik-cn-docs%2Fdocs%2Fsrc%2Froutes%2Fdocs%2F(qwik)%2Fcomponents%2Fevents%2Findex.mdx%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A113%2C%22character%22%3A0%7D%5D "docs/src/routes/docs/(qwik)/components/events/index.mdx") 对象。这个对象包含了触发处理程序的事件的信息。例如，`click` 事件的 [`Event`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22path%22%3A%22%2FUsers%2Fotto%2Fmycode%2Fqwik-cn-docs%2Fdocs%2Fsrc%2Froutes%2Fdocs%2F(qwik)%2Fcomponents%2Fevents%2Findex.mdx%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A113%2C%22character%22%3A0%7D%5D "docs/src/routes/docs/(qwik)/components/events/index.mdx") 对象包含了鼠标位置和被点击元素的信息。你可以查看 [MDN 文档以了解每个 DOM 事件的更多细节](https://developer.mozilla.org/en-US/docs/Web/API/Event)。

<CodeSandbox src="/src/routes/demo/events/mouse-position/index.tsx" style={{ height: '6em' }}>
```tsx /event/
import { component$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const position = useSignal<{ x: number; y: number }>();
  return (
    <div
      onClick$={(event) => (position.value = { x: event.x, y: event.y })}
      style="height: 100vh"
    >
      <p>
        Clicked at: ({position.value?.x}, {position.value?.y})
      </p>
    </div>
  );
});
```
</CodeSandbox>

## 异步事件

由于 Qwik 的异步特性，如果实现尚未加载到 JavaScript VM 中，事件处理程序的执行可能会被延迟。因此，Event 对象上的以下 API 将不起作用：

- `event.preventDefault()`
- `event.currentTarget`

### 阻止默认行为

因为事件处理是异步的，你不能使用 `event.preventDefault()`。为了解决这个问题，Qwik 引入了一种通过 `preventdefault:{eventName}` 属性来声明式阻止默认行为的方式。

<CodeSandbox src="/src/routes/demo/events/preventdefault/index.tsx" style={{ height: '6em' }}>
```tsx {7}
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return (
    <a
      href="/docs"
      preventdefault:click // This will prevent the default behavior of the "click" event.
      onClick$={() => {
        // event.PreventDefault() will not work here, because handler is dispatched asynchronously.
        alert('Do something else to simulate navigation...');
      }}
    >
      Go to docs page
    </a>
  );
});
```
</CodeSandbox>

### Event Target

因为事件处理是异步的，你不能使用 `event.currentTarget`。为了解决这个问题，Qwik 处理程序提供了 `currentTarget` 作为第二个参数。  

<CodeSandbox src="/src/routes/demo/events/target/index.tsx" style={{ height: '10em' }}>
```tsx /currentTarget/
import { component$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const currentElm = useSignal<HTMLElement|null>(null);
  const targetElm = useSignal<HTMLElement|null>(null);

  return (
    <section onClick$={(event, currentTarget) => {
      currentElm.value = currentTarget;
      targetElm.value = event.target as HTMLElement;
    }}>
      Click on any text <code>target</code> and <code>currentElm</code> of the event.
      <hr/>
      <p>Hello <b>World</b>!</p>
      <hr/>
      <ul>
        <li>currentElm: {currentElm.value?.tagName}</li>
        <li>target: {targetElm.value?.tagName}</li>
      </ul>
    </section>
  );
});
```
</CodeSandbox>

> **注意：**DOM 中的 `currentTarget` 指向事件监听器附加到的元素。在上面的例子中，它将始终是 `<SECTION>` 元素。

### 同步事件处理

在某些情况下，需要传统地处理事件，因为某些 API 需要同步使用。例如，`dragstart` 事件必须同步处理，因此它不能与 Qwik 的懒代码执行结合使用。

为此，你可以利用 `useVisibleTask` 来使用 DOM API 直接以编程方式添加事件监听器。

<CodeSandbox src="/src/routes/demo/events/synchronous/index.tsx" style={{ height: '10em' }}>
```tsx {7-20}
import { component$, useSignal, useVisibleTask$ } from '@builder.io/qwik';

export default component$(() => {
  const draggableRef = useSignal<HTMLElement>();
  const dragStatus = useSignal('');

  useVisibleTask$(({ cleanup }) => {
    if (draggableRef.value) {
      // Use the DOM API to add an event listener.
      const dragstart = () => (dragStatus.value = 'dragstart');
      const dragend = () => (dragStatus.value = 'dragend');

      draggableRef.value!.addEventListener('dragstart', dragstart);
      draggableRef.value!.addEventListener('dragend', dragend);
      cleanup(() => {
        draggableRef.value!.removeEventListener('dragstart', dragstart);
        draggableRef.value!.removeEventListener('dragend', dragend);
      });
    }
  });

  return (
    <div>
      <div draggable ref={draggableRef}>
        Drag me!
      </div>
      <p>{dragStatus.value}</p>
    </div>
  );
});
```
</CodeSandbox>


> **注意** 在 Qwik 中使用 `VisibleTask` 来监听事件是一种反模式，因为它导致代码在浏览器中急切执行，从而破坏了可恢复性。只有在别无选择时才使用它。你应该使用 JSX 来监听事件，例如：`<div onClick$={...}>`。或者，如果你需要以编程方式监听事件，考虑使用 `useOn(...)` 事件方法。

## 自定义事件属性

在创建组件时，经常需要传递类似于事件处理程序的自定义事件属性，即使它们只是回调而不是实际的 DOM 事件。Qwik 中的组件边界必须是可序列化的，以便优化器将它们分割成单独的块。函数除非被转换为 QRL，否则不可序列化。

例如，监听三次点击事件，这是 html 默认无法做到的，将需要创建一个 `onTripleClick$` 自定义事件属性。

<CodeSandbox src="/src/routes/demo/events/custom-event/index.tsx" style={{ height: '10em' }}>
```tsx
import { component$, Slot, useStore } from '@builder.io/qwik';

export default component$(() => {
  return (
    <Button onTripleClick$={() => alert('TRIPLE CLICKED!')}>
      Triple Click me!
    </Button>
  );
});

type ButtonProps = {
  onTripleClick$: QRL<() => void>;
};

export const Button = component$<ButtonProps>(({ onTripleClick$ }) => {
  const state = useStore({
    clicks: 0,
    lastClickTime: 0,
  });
  return (
    <button
      onClick$={() => {
        // triple click logic
        const now = Date.now();
        const timeBetweenClicks = now - state.lastClickTime;
        state.lastClickTime = now;
        if (timeBetweenClicks > 500) {
          state.clicks = 0;
        }
        state.clicks++;
        if (state.clicks === 3) {
          // handle custom event
          onTripleClick$();
          state.clicks = 0;
        }
      }}
    >
      <Slot />
    </button>
  );
});
```
</CodeSandbox>

> 注意在 `onTripleClick$: QRL<() => void>;` 中使用了 `QRL` 类型。这就像在类型级别上将函数包装在 `$()` 中。如果你有 `const greet = $(() => "hi 👋");` 并且悬停在 'greet' 上，你会看到 'greet' 的类型是 `QRL<() => "hi 👋">`

## 窗口和文档事件

到目前为止，讨论主要集中在监听来自元素的事件上。有一些事件，如 `scroll` 和 `mousemove`，需要在 `window` 或 `document` 上监听。Qwik 通过提供在监听事件时使用的 `document:on` 和 `window:on` 前缀来实现这一点。

`window:on`/`document:` 前缀用于在组件的当前 DOM 位置注册事件，同时允许它从 `window`/`document` 接收事件。这样做有两个优点：

1. 事件可以在 JSX 中声明式注册。
2. 当组件被销毁时，事件会自动清理（不需要显式的簿记和清理）。

## `useOn[window|document]` Hook

- `useOn()`: 在当前组件的根元素上监听事件。
- `useOnWindow()`: 在 `window` 对象上监听事件。
- `useOnDocument()`: 在 `document` 对象上监听事件。

`useOn[window|document]()` hook 将以编程方式在组件级别添加基于 DOM 的事件监听器。当你想创建自己的使用钩子或在编译时不知道事件名称时，这通常很有用。

<CodeSandbox src="/src/routes/demo/events/use-on/index.tsx" style={{ height: '10em' }}>
```tsx
import { $, component$, useOnDocument, useStore } from '@builder.io/qwik';

// Assume reusable use method that does not have access to JSX
// but needs to register event handlers.
function useMousePosition() {
  const position = useStore({ x: 0, y: 0 });
  useOnDocument(
    'mousemove',
    $((event) => {
      const { x, y } = event as MouseEvent;
      position.x = x;
      position.y = y;
    })
  );
  return position;
}

export default component$(() => {
  const pos = useMousePosition();
  return (
    <div>
      MousePosition: ({pos.x}, {pos.y})
    </div>
  );
});
```
</CodeSandbox>
