---
title: State | Components
keywords: 'useState, state management, reactivity, reactive'
contributors:
  - nnelgxorz
  - the-r3aper7
  - voluntadpear
  - kawamataryo
  - JaymanW
  - RATIU5
  - manucorporat
  - literalpie
  - fum4
  - cunzaizhuyi
  - zanettin
  - ChristianAnagnostou
  - shairez
  - forresst
  - almilo
  - Craiqser
  - XiaoChengyin
  - gkatsanos
  - adamdbradley
  - mhevery
  - wtlin1228
  - AnthonyPAlicea
  - sreeisalso
  - wmertens
  - nicvazquez
  - mrhoodz
  - eecopa
  - fabian-hiller
  - julianobrasil
  - aivarsliepa
  - Balastrong
  - Jemsco
updated_at: '2023-10-04T21:48:45Z'
created_at: '2023-03-20T23:45:13Z'
---

import CodeSandbox from '../../../../../components/code-sandbox/index.tsx';

# çŠ¶æ€

çŠ¶æ€ç®¡ç†æ˜¯ä»»ä½•åº”ç”¨ç¨‹åºçš„é‡è¦éƒ¨åˆ†ã€‚åœ¨ Qwik ä¸­ï¼Œæœ‰ä¸¤ç§ç±»å‹çš„çŠ¶æ€ï¼Œå“åº”å¼å’Œé™æ€ï¼š

1. é™æ€çŠ¶æ€æ˜¯ä»»ä½•å¯ä»¥åºåˆ—åŒ–çš„ä¸œè¥¿ï¼šå­—ç¬¦ä¸²ã€æ•°å­—ã€å¯¹è±¡ã€æ•°ç»„â€¦â€¦ä»»ä½•ä¸œè¥¿ã€‚
2. å¦ä¸€æ–¹é¢ï¼Œå“åº”å¼çŠ¶æ€æ˜¯é€šè¿‡ `useSignal()` æˆ– `useStore()` åˆ›å»ºçš„ã€‚

é‡è¦çš„æ˜¯è¦æ³¨æ„ï¼Œåœ¨ Qwik ä¸­çš„çŠ¶æ€ä¸ä¸€å®šæ˜¯å±€éƒ¨ç»„ä»¶çŠ¶æ€ï¼Œè€Œæ˜¯å¯ä»¥ç”±ä»»ä½•ç»„ä»¶å®ä¾‹åŒ–çš„åº”ç”¨çŠ¶æ€ã€‚

## `useSignal()`

ä½¿ç”¨ `useSignal()` åˆ›å»ºä¸€ä¸ªå“åº”å¼ä¿¡å·ï¼ˆä¸€ç§çŠ¶æ€ï¼‰ã€‚`useSignal()` æ¥å—ä¸€ä¸ªåˆå§‹å€¼å¹¶è¿”å›ä¸€ä¸ªå“åº”å¼ä¿¡å·ã€‚

å“åº”å¼ä¿¡å·è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ª `.value` å±æ€§ã€‚å¦‚æœæ›´æ”¹ä¿¡å·çš„ `value` å±æ€§ï¼Œä¾èµ–äºå®ƒçš„ä»»ä½•ç»„ä»¶éƒ½å°†è‡ªåŠ¨æ›´æ–°ã€‚

<CodeSandbox src="/src/routes/demo/state/counter-signal/index.tsx" style={{ height: '6em' }}>
```tsx {4} /count/
import { component$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const count = useSignal(0);

  return (
    <button onClick$={() => count.value++}>
      Increment {count.value}
    </button>
  );
});
```
</CodeSandbox>

è¿™ä¸ªä¾‹å­å±•ç¤ºäº†å¦‚ä½•åœ¨è®¡æ•°å™¨ç»„ä»¶ä¸­ä½¿ç”¨ `useSignal()` æ¥è·Ÿè¸ªè®¡æ•°ã€‚ä¿®æ”¹ `count.value` å±æ€§å°†è‡ªåŠ¨æ›´æ–°ç»„ä»¶ã€‚ä¾‹å¦‚ï¼Œå½“åœ¨æŒ‰é’®ç‚¹å‡»å¤„ç†ç¨‹åºä¸­æ›´æ”¹å±æ€§æ—¶ï¼Œå¦‚ä¸Šä¾‹æ‰€ç¤ºã€‚

## `useStore()`

å’Œ `useSignal()` ç±»ä¼¼ï¼Œä½†æ˜¯å®ƒä»¥å¯¹è±¡ä½œä¸ºåˆå§‹å€¼ï¼Œå¹¶é»˜è®¤æƒ…å†µä¸‹å°†åµŒå¥—å¯¹è±¡å’Œæ•°ç»„çš„ååº”æ€§æ‰©å±•åˆ°æ·±å±‚ã€‚å¯ä»¥å°†å­˜å‚¨è§†ä¸ºå¤šå€¼ä¿¡å·æˆ–ç”±å¤šä¸ªä¿¡å·ç»„æˆçš„å¯¹è±¡ã€‚

ä½¿ç”¨ `useStore(initialStateObject)` é’©å­åˆ›å»ºä¸€ä¸ªå“åº”å¼å¯¹è±¡ã€‚å®ƒæ¥å—ä¸€ä¸ªåˆå§‹å¯¹è±¡ï¼ˆæˆ–å·¥å‚å‡½æ•°ï¼‰å¹¶è¿”å›ä¸€ä¸ªå“åº”å¼å¯¹è±¡ã€‚

<CodeSandbox src="/src/routes/demo/state/counter-store/index.tsx" style={{ height: '6em' }} >
```tsx {4} /state/ /count/#a
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const state = useStore({ count: 0, name: 'Qwik' });

  return (
    <>
      <button onClick$={() => state.count++}>Increment</button>
      <p>Count: {state.count}</p>
      <input
        value={state.name}
        onInput$={(_, el) => (state.name = el.value)}
      />
    </>
  );
});
```
</CodeSandbox>

> **æ³¨æ„** ä¸ºäº†ä½¿å“åº”æ€§æŒ‰é¢„æœŸå·¥ä½œï¼Œè¯·ç¡®ä¿ä¿ç•™å¯¹å“åº”å¼å¯¹è±¡çš„å¼•ç”¨ï¼Œè€Œä¸ä»…ä»…æ˜¯å¯¹å…¶å±æ€§çš„å¼•ç”¨ã€‚ä¾‹å¦‚ï¼Œæ‰§è¡Œ `let { count } = useStore({ count: 0 })`ï¼Œç„¶åå¯¹ `count` è¿›è¡Œçªå˜ä¸ä¼šè§¦å‘ä¾èµ–äºè¯¥å±æ€§çš„ç»„ä»¶çš„æ›´æ–°ã€‚

å› ä¸º [`useStore()`](/docs/(qwik)/components/state/index.mdx#usestore) è·Ÿè¸ªæ·±å±‚ååº”æ€§ï¼Œè¿™æ„å‘³ç€å­˜å‚¨ä¸­çš„æ•°ç»„å’Œå¯¹è±¡ä¹Ÿå°†æ˜¯å“åº”å¼çš„ã€‚

<CodeSandbox src="/src/routes/demo/state/counter-store-deep/index.tsx" style={{ height: '10em' }}>
```tsx
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const store = useStore({
    nested: {
      fields: { are: 'also tracked' },
    },
    list: ['Item 1'],
  });

  return (
    <>
      <p>{store.nested.fields.are}</p>
      <button
        onClick$={() => {
          // Even though we are mutating a nested object, this will trigger a re-render
          store.nested.fields.are = 'tracked';
        }}
      >
        Clicking me works because store is deep watched
      </button>
      <br />
      <button
        onClick$={() => {
          // Because store is deep watched, this will trigger a re-render
          store.list.push(`Item ${store.list.length}`);
        }}
      >
        Add to list
      </button>
      <ul>
        {store.list.map((item, key) => (
          <li key={key}>{item}</li>
        ))}
      </ul>
    </>
  );
});
```
</CodeSandbox>

æ³¨æ„ï¼Œä¸ºäº†è·Ÿè¸ªæ‰€æœ‰åµŒå¥—å±æ€§ï¼Œ`useStore()` éœ€è¦åˆ†é…å¤§é‡çš„ä»£ç†å¯¹è±¡ã€‚å¦‚æœæœ‰å¾ˆå¤šåµŒå¥—å±æ€§ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´æ€§èƒ½é—®é¢˜ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥ä½¿ç”¨ `deep: false` é€‰é¡¹ä»…è·Ÿè¸ªé¡¶çº§å±æ€§ã€‚

```tsx
const shallowStore = useStore(
  {
    nested: {
      fields: { are: 'also tracked' }
    },
    list: ['Item 1'],
  },
  { deep: false }
);
```
> **å¤„ç†åŠ¨æ€å¯¹è±¡çªå˜**
>
> å½“åŠ¨æ€æ“ä½œå¯¹è±¡å±æ€§æ—¶ï¼Œä¾‹å¦‚åœ¨åº”ç”¨ç¨‹åºçš„æŸå¤„æ¸²æŸ“å®ƒä»¬æ—¶åˆ é™¤å®ƒä»¬ï¼Œå¯èƒ½ä¼šé‡åˆ°é—®é¢˜ã€‚å¦‚æœç»„ä»¶å‘ˆç°ä¾èµ–äºå½“å‰æ­£åœ¨åˆ é™¤çš„å¯¹è±¡å±æ€§çš„å€¼ï¼Œåˆ™å¯èƒ½ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µã€‚ä¸ºäº†é˜²æ­¢è¿™ç§æƒ…å†µï¼Œè®¿é—®å±æ€§æ—¶è¯·ä½¿ç”¨å¯é€‰é“¾æ¥ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå°è¯•åˆ é™¤å±æ€§ï¼š
> ```tsx
> delete store.propertyName;
> ```
> è¯·ç¡®è®¤åœ¨ç»„ä»¶ä¸­è°¨æ…è®¿é—®æ­¤å±æ€§ï¼Œä¾‹å¦‚ä½¿ç”¨å¯é€‰é“¾æ¥( ?. ):
> ```tsx
> const propertyValue = store.propertyName?.value;
> ```




### Methods

ä¸ºäº†åœ¨ store ä¸Šæä¾›æ–¹æ³•ï¼Œæ‚¨å¿…é¡»å°†å®ƒä»¬è½¬æ¢ä¸º QRLï¼Œå¹¶ä½¿ç”¨ `this` å¼•ç”¨å­˜å‚¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```tsx
import { component$, useStore, $, type QRL } from "@builder.io/qwik";

type CountStore = { count: number; increment: QRL<(this: CountStore) => void> };

export default component$(() => {
  const state = useStore<CountStore>({
    count: 0,
    increment: $(function (this: CountStore) {
      this.count++;
    }),
  });

  return (
    <>
      <button onClick$={() => state.increment()}>Increment</button>
      <p>Count: {state.count}</p>
    </>
  );
});
```

> ä½ çŸ¥é“ä¸ºä»€ä¹ˆåº”è¯¥åœ¨ `useStore()` ä¸­ä½¿ç”¨å¸¸è§„çš„ `function(){}` è€Œä¸æ˜¯ç®­å¤´å‡½æ•°å—ï¼Ÿè¿™æ˜¯å› ä¸ºåœ¨ javascript ä¸­ï¼Œ[ç®­å¤´å‡½æ•°æ²¡æœ‰è‡ªå·±çš„ `this` ç»‘å®š](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)ã€‚è¿™æ„å‘³ç€å¦‚æœå°è¯•ä½¿ç”¨ç®­å¤´å‡½æ•°è®¿é—® `this`ï¼Œ`this.count` å¯èƒ½æŒ‡å‘å¦ä¸€ä¸ªå¯¹è±¡çš„ `count` ğŸ˜±ã€‚

## è®¡ç®—çŠ¶æ€

åœ¨ Qwik ä¸­ï¼Œæœ‰ä¸¤ç§åˆ›å»ºè®¡ç®—å€¼çš„æ–¹æ³•ï¼Œæ¯ç§æ–¹æ³•éƒ½æœ‰ä¸åŒçš„ç”¨ä¾‹ï¼ˆæŒ‰ä¼˜å…ˆé¡ºåºï¼‰ï¼š

1. `useComputed$()`: `useComputed$()` æ˜¯åˆ›å»ºè®¡ç®—å€¼çš„é¦–é€‰æ–¹æ³•ã€‚å½“è®¡ç®—å€¼å¯ä»¥çº¯ç²¹ä»æºçŠ¶æ€ï¼ˆå½“å‰åº”ç”¨ç¨‹åºçŠ¶æ€ï¼‰åŒæ­¥æ´¾ç”Ÿæ—¶ï¼Œè¯·ä½¿ç”¨å®ƒã€‚ä¾‹å¦‚ï¼Œåˆ›å»ºå­—ç¬¦ä¸²çš„å°å†™ç‰ˆæœ¬æˆ–å°†åå­—å’Œå§“æ°ç»„åˆæˆå…¨åã€‚

2. [`useResource$()`](/docs/(qwik)/components/state/index.mdx#useresource): å½“è®¡ç®—å€¼æ˜¯å¼‚æ­¥çš„æˆ–çŠ¶æ€æ¥è‡ªåº”ç”¨ç¨‹åºå¤–éƒ¨æ—¶ï¼Œä½¿ç”¨ `useResource$()`ã€‚ä¾‹å¦‚ï¼Œæ ¹æ®å½“å‰ä½ç½®ï¼ˆåº”ç”¨ç¨‹åºå†…éƒ¨çŠ¶æ€ï¼‰è·å–å½“å‰å¤©æ°”ï¼ˆå¤–éƒ¨çŠ¶æ€ï¼‰ã€‚

é™¤äº†ä¸Šé¢æè¿°çš„ä¸¤ç§åˆ›å»ºè®¡ç®—å€¼çš„æ–¹æ³•ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ç§æ›´ä½çº§åˆ«çš„æ–¹æ³•ï¼ˆ[`useTask$()`](/docs/(qwik)/components/tasks/index.mdx#usetask)ï¼‰ã€‚è¿™ç§æ–¹å¼ä¸ä¼šäº§ç”Ÿæ–°çš„ä¿¡å·ï¼Œè€Œæ˜¯ä¿®æ”¹ç°æœ‰çŠ¶æ€æˆ–äº§ç”Ÿå‰¯ä½œç”¨ã€‚

### `useComputed$()`

ä½¿ç”¨ `useComputed$()` åˆ›å»ºä¸€ä¸ªè®¡ç®—å€¼ï¼Œè¯¥å€¼ä»å…¶ä»–çŠ¶æ€åŒæ­¥æ´¾ç”Ÿã€‚

å®ƒç±»ä¼¼äºå…¶ä»–æ¡†æ¶ä¸­çš„ `memo`ï¼Œå› ä¸ºå®ƒåªä¼šåœ¨è¾“å…¥ä¿¡å·ä¹‹ä¸€å‘ç”Ÿæ›´æ”¹æ—¶é‡æ–°è®¡ç®—å€¼ã€‚


<CodeSandbox src="/src/routes/demo/state/computed/index.tsx" style={{ height: '8em' }}>
```tsx {5} /useComputed$/
import { component$, useComputed$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const name = useSignal('Qwik');
  const capitalizedName = useComputed$(() => {
    // it will automatically reexecute when name.value changes
    return name.value.toUpperCase();
  });

  return (
    <>
      <input type="text" bind:value={name} />
      <p>Name: {name.value}</p>
      <p>Capitalized name: {capitalizedName.value}</p>
    </>
  );
});
```
</CodeSandbox>

> **æ³¨æ„** ç”±äº `useComputed$()` æ˜¯åŒæ­¥çš„ï¼Œå› æ­¤ä¸éœ€è¦æ˜¾å¼è·Ÿè¸ªè¾“å…¥ä¿¡å·ã€‚

### `useResource$()`

ä½¿ç”¨ `useResource$()` åˆ›å»ºä¸€ä¸ªå¼‚æ­¥æ´¾ç”Ÿçš„è®¡ç®—å€¼ã€‚å®ƒæ˜¯ `useComputed$()` çš„å¼‚æ­¥ç‰ˆæœ¬ï¼ŒåŒ…æ‹¬å€¼ä¹‹ä¸Šçš„èµ„æºçŠ¶æ€ï¼ˆåŠ è½½ä¸­ã€å·²è§£æã€å·²æ‹’ç»ï¼‰ã€‚

`useResource$()` çš„å¸¸è§ç”¨æ³•æ˜¯åœ¨ç»„ä»¶å†…éƒ¨ä»å¤–éƒ¨ API è·å–æ•°æ®ï¼Œè¿™å¯èƒ½å‘ç”Ÿåœ¨æœåŠ¡å™¨ç«¯æˆ–å®¢æˆ·ç«¯ã€‚

`useResource$` é’©å­æ˜¯ä¸º `<Resource />` è®¾è®¡çš„ã€‚`<Resource />` ç»„ä»¶æ˜¯æ ¹æ®èµ„æºçŠ¶æ€æ¸²æŸ“ä¸åŒ UI çš„ä¸€ç§ä¾¿æ·æ–¹å¼ã€‚

<CodeSandbox src="/src/routes/demo/state/resource/index.tsx" style={{ height: '8em' }}>
```tsx {11} /useResource$/
import {
  component$,
  Resource,
  useResource$,
  useSignal,
} from '@builder.io/qwik';

export default component$(() => {
  const prNumber = useSignal('3576');

  const prTitle = useResource$<string>(async ({ track }) => {
    // it will run first on mount (server), then re-run whenever prNumber changes (client)
    // this means this code will run on the server and the browser
    track(() => prNumber.value);
    const response = await fetch(
      `https://api.github.com/repos/QwikDev/qwik/pulls/${prNumber.value}`
    );
    const data = await response.json();
    return data.title as string;
  });

  return (
    <>
      <input type="number" bind:value={prNumber} />
      <h1>PR#{prNumber}:</h1>
      <Resource
        value={prTitle}
        onPending={() => <p>Loading...</p>}
        onResolved={(title) => <h2>{title}</h2>}
      />
    </>
  );
});
```
</CodeSandbox>



> **æ³¨æ„** å…³äº `useResource$` çš„é‡è¦äº‹é¡¹æ˜¯å®ƒåœ¨åˆå§‹ç»„ä»¶æ¸²æŸ“æ—¶æ‰§è¡Œï¼ˆå°±åƒ `useTask$` ä¸€æ ·ï¼‰ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œå¸Œæœ›åœ¨æœåŠ¡å™¨ä¸Šçš„åˆå§‹ HTTP è¯·æ±‚ä¸­å¼€å§‹è·å–æ•°æ®ï¼Œä»¥ä¾¿åœ¨ç»„ä»¶æ¸²æŸ“ä¹‹å‰ã€‚åœ¨æœåŠ¡å™¨ç«¯æ¸²æŸ“ï¼ˆSSRï¼‰æœŸé—´è·å–æ•°æ®æ˜¯ä¸€ç§å¸¸è§ä¸”é¦–é€‰çš„æ•°æ®åŠ è½½æ–¹æ³•ï¼Œé€šå¸¸ç”± [`routeLoader$`](/docs/(qwikcity)/route-loader/index.mdx) API å¤„ç†ã€‚`useResource$` æ˜¯ä¸€ç§æ›´ä½çº§åˆ«çš„ APIï¼Œå½“æ‚¨æƒ³åœ¨æµè§ˆå™¨ä¸­è·å–æ•°æ®æ—¶éå¸¸æœ‰ç”¨ã€‚
>
>
> å¾ˆå¤šæ–¹é¢ `useResource$` ä¸ `useTask$` ç›¸ä¼¼ã€‚ä¸»è¦åŒºåˆ«æ˜¯ï¼š
>
> - `useResource$` å…è®¸æ‚¨è¿”å›ä¸€ä¸ªâ€œå€¼â€ã€‚
> - `useResource$` ä¼šåœ¨ç»„ä»¶çš„åˆå§‹æ¸²æŸ“æ—¶è¿è¡Œï¼Œç„¶ååœ¨èµ„æºçŠ¶æ€æ›´æ”¹æ—¶é‡æ–°è¿è¡Œã€‚
>
> æŸ¥é˜… [`routeLoader$`](/docs/(qwikcity)/route-loader/index.mdx) ä»¥è·å–æ•°æ®çš„æ—©æœŸåŠ è½½ä½œä¸ºåˆå§‹ HTTP è¯·æ±‚çš„ä¸€éƒ¨åˆ†ã€‚

> **æ³¨æ„** åœ¨ SSR æœŸé—´ï¼Œ`<Resource>` ç»„ä»¶å°†æš‚åœæ¸²æŸ“ï¼Œç›´åˆ°èµ„æºè§£æã€‚è¿™æ · SSR å°†ä¸ä¼šä½¿ç”¨åŠ è½½æŒ‡ç¤ºå™¨æ¸²æŸ“ã€‚

#### é«˜çº§ç¤ºä¾‹

ä¸€ä¸ªæ›´å®Œæ•´çš„ç¤ºä¾‹ï¼Œä½¿ç”¨ `AbortController`ã€`track` å’Œ `cleanup` è·å–æ•°æ®ã€‚è¿™ä¸ªç¤ºä¾‹å°†æ ¹æ®ç”¨æˆ·è¾“å…¥çš„æŸ¥è¯¢è·å–ç¬‘è¯åˆ—è¡¨ï¼Œè‡ªåŠ¨å“åº”æŸ¥è¯¢çš„æ›´æ”¹ï¼ŒåŒ…æ‹¬ä¸­æ­¢å½“å‰æ­£åœ¨è¿›è¡Œçš„è¯·æ±‚ã€‚

<CodeSandbox src="/src/routes/demo/state/resource-joke/index.tsx" style={{ height: '40em' }}>
```tsx {11} /useResource$/
import {
  component$,
  useResource$,
  Resource,
  useSignal,
} from '@builder.io/qwik';

export default component$(() => {
  const query = useSignal('busy');
  const jokes = useResource$<{ value: string }[]>(
    async ({ track, cleanup }) => {
      track(() => query.value);
      // A good practice is to use `AbortController` to abort the fetching of data if
      // new request comes in. We create a new `AbortController` and register a `cleanup`
      // function which is called when this function re-runs.
      const controller = new AbortController();
      cleanup(() => controller.abort());

      if (query.value.length < 3) {
        return [];
      }

      const url = new URL('https://api.chucknorris.io/jokes/search');
      url.searchParams.set('query', query.value);

      const resp = await fetch(url, { signal: controller.signal });
      const json = (await resp.json()) as { result: { value: string }[] };

      return json.result;
    }
  );

  return (
    <>
      <label>
        Query: <input bind:value={query} />
      </label>
      <button>search</button>
      <Resource
        value={jokes}
        onPending={() => <>loading...</>}
        onResolved={(jokes) => (
          <ul>
            {jokes.map((joke, i) => (
              <li key={i}>{joke.value}</li>
            ))}
          </ul>
        )}
      />
    </>
  );
});
```
</CodeSandbox>

æ­£å¦‚æˆ‘ä»¬åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­çœ‹åˆ°çš„ï¼Œ`useResource$()` è¿”å›ä¸€ä¸ª `ResourceReturn<T>` å¯¹è±¡ï¼Œå®ƒçš„å·¥ä½œæ–¹å¼ç±»ä¼¼äºä¸€ä¸ªå“åº”å¼ promiseï¼ŒåŒ…å«æ•°æ®å’Œèµ„æºçŠ¶æ€ã€‚

çŠ¶æ€ `resource.loading` å¯ä»¥æ˜¯ä»¥ä¸‹ä¹‹ä¸€ï¼š

- `false` - æ•°æ®å°šä¸å¯ç”¨ã€‚
- `true` - æ•°æ®å¯ç”¨ã€‚ (å·²è§£ææˆ–å·²æ‹’ç»ã€‚)

ä¼ é€’ç»™ [`useResource$()`](/docs/(qwik)/components/state/index.mdx#useresource) çš„å›è°ƒåœ¨ [`useTask$()`](/docs/(qwik)/components/tasks/index.mdx#usetask) å›è°ƒå®Œæˆåç«‹å³è¿è¡Œã€‚æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… [ç”Ÿå‘½å‘¨æœŸ](../tasks/index.mdx#lifecycle) éƒ¨åˆ†ã€‚

#### `<Resource />`

`<Resource />` is a component meant to be used with the `useResource$()` that renders different content depending on if the resource is pending, resolved, or rejected.
`<Resource />` æ˜¯ä¸€ä¸ªç»„ä»¶ï¼Œç”¨äºä¸ `useResource$()` ä¸€èµ·ä½¿ç”¨ï¼Œæ ¹æ®èµ„æºçš„çŠ¶æ€ï¼ˆpendingã€resolvedã€rejectedï¼‰æ¸²æŸ“ä¸åŒçš„å†…å®¹ã€‚

```tsx
<Resource
  value={weatherResource}
  onPending={() => <div>Loading...</div>}
  onRejected={() => <div>Failed to load weather</div>}
  onResolved={(weather) => {
    return <div>Temperature: {weather.temp}</div>;
  }}
/>
```

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä½¿ç”¨ useResource$() æ—¶ï¼Œä¸éœ€è¦ <Resource />ã€‚è¿™åªæ˜¯ä¸€ç§æ–¹ä¾¿çš„æ–¹å¼æ¥æ¸²æŸ“èµ„æºçŠ¶æ€ã€‚

è¿™æ˜¯ä¸€ä¸ªæ›´ç®€å•çš„ç¤ºä¾‹ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ `useResource$` æ¥æ‰§è¡Œå¯¹ [agify.io](https://agify.io/) API çš„ fetch è°ƒç”¨ã€‚è¿™å°†æ ¹æ®ç”¨æˆ·è¾“å…¥çš„åç§°çŒœæµ‹ä¸€ä¸ªäººçš„å¹´é¾„ï¼Œå¹¶åœ¨ç”¨æˆ·è¾“å…¥åç§°æ—¶æ›´æ–°ã€‚


<CodeSandbox src="/src/routes/demo/state/resource-agify/index.tsx" style={{ height: '8em' }}>
```tsx {11} /useResource$/
import {
  component$,
  useSignal,
  useResource$,
  Resource,
} from '@builder.io/qwik';

export default component$(() => {
  const name = useSignal<string>();

  const ageResource = useResource$<{
    name: string;
    age: number;
    count: number;
  }>(async ({ track, cleanup }) => {
    track(() => name.value);
    const abortController = new AbortController();
    cleanup(() => abortController.abort('cleanup'));
    const res = await fetch(`https://api.agify.io?name=${name.value}`, {
      signal: abortController.signal,
    });
    return res.json();
  });

  return (
    <section>
      <div>
        <label>
          Enter your name, and I'll guess your age!
          <input onInput$={(ev, el) => (name.value = el.value)} />
        </label>
      </div>
      <Resource
        value={ageResource}
        onPending={() => <p>Loading...</p>}
        onRejected={() => <p>Failed to person data</p>}
        onResolved={(ageGuess) => {
          return (
            <p>
              {name.value && (
                <>
                  {ageGuess.name} {ageGuess.age} years
                </>
              )}
            </p>
          );
        }}
      />
    </section>
  );
});
```
</CodeSandbox>

## ä¼ é€’çŠ¶æ€

Qwik çš„ä¸€ä¸ªå¥½ç‰¹æ€§æ˜¯å¯ä»¥å°†çŠ¶æ€ä¼ é€’ç»™å…¶ä»–ç»„ä»¶ã€‚è¿™æ ·ï¼Œåªæœ‰ä»å­˜å‚¨ä¸­è¯»å–çš„ç»„ä»¶ä¼šè¢«é‡æ–°æ¸²æŸ“ã€‚

æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥å°†çŠ¶æ€ä¼ é€’ç»™å…¶ä»–ç»„ä»¶ï¼š

1. é€šè¿‡ props æ˜ç¡®åœ°å°†çŠ¶æ€ä¼ é€’ç»™å­ç»„ä»¶ï¼Œ
2. æˆ–è€…é€šè¿‡ä¸Šä¸‹æ–‡éšå¼åœ°ä¼ é€’çŠ¶æ€ã€‚

### ä½¿ç”¨ props

å°†çŠ¶æ€ä¼ é€’ç»™å…¶ä»–ç»„ä»¶æœ€ç®€å•çš„æ–¹å¼æ˜¯é€šè¿‡ props ä¼ é€’ã€‚

<CodeSandbox src="/src/routes/demo/state/passing-props/index.tsx" style={{ height: '6em' }}>
```tsx {9} /userData=/
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const userData = useStore({ count: 0 });
  return <Child userData={userData} />;
});

interface ChildProps {
  userData: { count: number };
}
export const Child = component$<ChildProps>(({ userData }) => {
  return (
    <>
      <button onClick$={() => userData.count++}>Increment</button>
      <p>Count: {userData.count}</p>
    </>
  );
});
```
</CodeSandbox>

### ä½¿ç”¨ä¸Šä¸‹æ–‡

ä¸Šä¸‹æ–‡ API æ˜¯ä¸€ç§å°†çŠ¶æ€ä¼ é€’ç»™ç»„ä»¶çš„æ–¹å¼ï¼Œæ— éœ€é€šè¿‡ props ä¼ é€’ï¼ˆå³ï¼šé¿å…äº† prop é’»å–é—®é¢˜ï¼‰ã€‚è‡ªåŠ¨åœ°ï¼Œæ ‘ä¸­çš„æ‰€æœ‰åä»£ç»„ä»¶éƒ½å¯ä»¥è®¿é—®çŠ¶æ€çš„å¼•ç”¨ï¼Œå¹¶å¯¹å…¶è¿›è¡Œè¯»/å†™è®¿é—®ã€‚

æŸ¥çœ‹ [ä¸Šä¸‹æ–‡ API](../context/index.mdx) äº†è§£æ›´å¤šä¿¡æ¯ã€‚

<CodeSandbox src="/src/routes/demo/state/passing-context/index.tsx" style={{ height: '6em' }}>
```tsx /userData/ /export const CTX = createContextId<{ count: number }>('stuff');/ /useContextProvider(CTX, userData);/ /const userData = useContext(CTX);/
import {
  component$,
  createContextId,
  useContext,
  useContextProvider,
  useStore,
} from '@builder.io/qwik';

// Declare a context ID
export const CTX = createContextId<{ count: number }>('stuff');

export default component$(() => {
  const userData = useStore({ count: 0 });

  // Provide the store to the context under the context ID
  useContextProvider(CTX, userData);

  return <Child />;
});

export const Child = component$(() => {
  const userData = useContext(CTX);
  return (
    <>
      <button onClick$={() => userData.count++}>Increment</button>
      <p>Count: {userData.count}</p>
    </>
  );
});
```
</CodeSandbox>

## `noSerialize()`

Qwik æ˜ç¡®è¦æ±‚æ‰€æœ‰åº”ç”¨ç¨‹åºçŠ¶æ€å§‹ç»ˆæ˜¯å¯åºåˆ—åŒ–çš„ã€‚è¿™æ˜¯ä¸ºäº†ç¡®ä¿ Qwik åº”ç”¨ç¨‹åºå…·æœ‰ [å¯æ¢å¤æ€§](/docs/(qwik)/concepts/resumable/index.mdx) ç‰¹æ€§ã€‚

æœ‰æ—¶ï¼Œéœ€è¦å­˜å‚¨æ— æ³•åºåˆ—åŒ–çš„æ•°æ®ï¼›`noSerialize()` æŒ‡ç¤º Qwik ä¸è¦å°è¯•åºåˆ—åŒ–æ ‡è®°çš„å€¼ã€‚ 
ä¾‹å¦‚ï¼Œå¯¹äºç¬¬ä¸‰æ–¹åº“çš„å¼•ç”¨ï¼Œå¦‚ [Monaco ç¼–è¾‘å™¨](https://microsoft.github.io/monaco-editor/)ï¼Œå°†å§‹ç»ˆéœ€è¦ `noSerialize()`ï¼Œå› ä¸ºå®ƒä¸å¯åºåˆ—åŒ–ã€‚

å¦‚æœå°†å€¼æ ‡è®°ä¸ºä¸å¯åºåˆ—åŒ–ï¼Œåˆ™è¯¥å€¼å°†ä¸ä¼šåœ¨åºåˆ—åŒ–äº‹ä»¶ï¼ˆä¾‹å¦‚ä» SSR æ¢å¤åº”ç”¨ç¨‹åºæ—¶ï¼‰ä¸­ä¿ç•™ï¼Œæ­¤æ—¶è¯¥å€¼å°†è®¾ç½®ä¸º `undefined`ï¼Œå¼€å‘äººå‘˜éœ€è¦åœ¨å®¢æˆ·ç«¯é‡æ–°åˆå§‹åŒ–è¯¥å€¼ã€‚

<CodeSandbox src="/src/routes/demo/state/no-serialize/index.tsx" style={{ height: '8em' }}>
```tsx /noSerialize/
import {
  component$,
  useStore,
  useSignal,
  noSerialize,
  useVisibleTask$,
  type NoSerialize,
} from '@builder.io/qwik';
import type Monaco from './monaco';
import { monacoEditor } from './monaco';

export default component$(() => {
  const editorRef = useSignal<HTMLElement>();
  const store = useStore<{ monacoInstance: NoSerialize<Monaco> }>({
    monacoInstance: undefined,
  });

  useVisibleTask$(() => {
    const editor = monacoEditor.create(editorRef.value!, {
      value: 'Hello, world!',
    });
    // Monaco is not serializable, so we can't serialize it as part of SSR
    // We can however instantiate it on the client after the component is visible
    store.monacoInstance = noSerialize(editor);
  });
  return <div ref={editorRef}>loading...</div>;
});
```
</CodeSandbox>
