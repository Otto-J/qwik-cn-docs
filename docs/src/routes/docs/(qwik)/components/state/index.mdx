---
title: State | Components
keywords: 'useState, state management, reactivity, reactive'
contributors:
  - nnelgxorz
  - the-r3aper7
  - voluntadpear
  - kawamataryo
  - JaymanW
  - RATIU5
  - manucorporat
  - literalpie
  - fum4
  - cunzaizhuyi
  - zanettin
  - ChristianAnagnostou
  - shairez
  - forresst
  - almilo
  - Craiqser
  - XiaoChengyin
  - gkatsanos
  - adamdbradley
  - mhevery
  - wtlin1228
  - AnthonyPAlicea
  - sreeisalso
  - wmertens
  - nicvazquez
  - mrhoodz
  - eecopa
  - fabian-hiller
  - julianobrasil
  - aivarsliepa
  - Balastrong
  - Jemsco
updated_at: '2023-10-04T21:48:45Z'
created_at: '2023-03-20T23:45:13Z'
---

import CodeSandbox from '../../../../../components/code-sandbox/index.tsx';

# 状态

状态管理是任何应用程序的重要部分。在 Qwik 中，有两种类型的状态，响应式和静态：

1. 静态状态是任何可以序列化的东西：字符串、数字、对象、数组……任何东西。
2. 另一方面，响应式状态是通过 `useSignal()` 或 `useStore()` 创建的。

重要的是要注意，在 Qwik 中的状态不一定是局部组件状态，而是可以由任何组件实例化的应用状态。

## `useSignal()`

使用 `useSignal()` 创建一个响应式信号（一种状态）。`useSignal()` 接受一个初始值并返回一个响应式信号。

响应式信号返回一个对象，其中包含一个 `.value` 属性。如果更改信号的 `value` 属性，依赖于它的任何组件都将自动更新。

<CodeSandbox src="/src/routes/demo/state/counter-signal/index.tsx" style={{ height: '6em' }}>
```tsx {4} /count/
import { component$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const count = useSignal(0);

  return (
    <button onClick$={() => count.value++}>
      Increment {count.value}
    </button>
  );
});
```
</CodeSandbox>

这个例子展示了如何在计数器组件中使用 `useSignal()` 来跟踪计数。修改 `count.value` 属性将自动更新组件。例如，当在按钮点击处理程序中更改属性时，如上例所示。

## `useStore()`

和 `useSignal()` 类似，但是它以对象作为初始值，并默认情况下将嵌套对象和数组的反应性扩展到深层。可以将存储视为多值信号或由多个信号组成的对象。

使用 `useStore(initialStateObject)` 钩子创建一个响应式对象。它接受一个初始对象（或工厂函数）并返回一个响应式对象。

<CodeSandbox src="/src/routes/demo/state/counter-store/index.tsx" style={{ height: '6em' }} >
```tsx {4} /state/ /count/#a
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const state = useStore({ count: 0, name: 'Qwik' });

  return (
    <>
      <button onClick$={() => state.count++}>Increment</button>
      <p>Count: {state.count}</p>
      <input
        value={state.name}
        onInput$={(_, el) => (state.name = el.value)}
      />
    </>
  );
});
```
</CodeSandbox>

> **注意** 为了使响应性按预期工作，请确保保留对响应式对象的引用，而不仅仅是对其属性的引用。例如，执行 `let { count } = useStore({ count: 0 })`，然后对 `count` 进行突变不会触发依赖于该属性的组件的更新。

因为 [`useStore()`](/docs/(qwik)/components/state/index.mdx#usestore) 跟踪深层反应性，这意味着存储中的数组和对象也将是响应式的。

<CodeSandbox src="/src/routes/demo/state/counter-store-deep/index.tsx" style={{ height: '10em' }}>
```tsx
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const store = useStore({
    nested: {
      fields: { are: 'also tracked' },
    },
    list: ['Item 1'],
  });

  return (
    <>
      <p>{store.nested.fields.are}</p>
      <button
        onClick$={() => {
          // Even though we are mutating a nested object, this will trigger a re-render
          store.nested.fields.are = 'tracked';
        }}
      >
        Clicking me works because store is deep watched
      </button>
      <br />
      <button
        onClick$={() => {
          // Because store is deep watched, this will trigger a re-render
          store.list.push(`Item ${store.list.length}`);
        }}
      >
        Add to list
      </button>
      <ul>
        {store.list.map((item, key) => (
          <li key={key}>{item}</li>
        ))}
      </ul>
    </>
  );
});
```
</CodeSandbox>

注意，为了跟踪所有嵌套属性，`useStore()` 需要分配大量的代理对象。如果有很多嵌套属性，这可能会导致性能问题。在这种情况下，可以使用 `deep: false` 选项仅跟踪顶级属性。

```tsx
const shallowStore = useStore(
  {
    nested: {
      fields: { are: 'also tracked' }
    },
    list: ['Item 1'],
  },
  { deep: false }
);
```
> **处理动态对象突变**
>
> 当动态操作对象属性时，例如在应用程序的某处渲染它们时删除它们，可能会遇到问题。如果组件呈现依赖于当前正在删除的对象属性的值，则可能会发生这种情况。为了防止这种情况，访问属性时请使用可选链接。例如，如果尝试删除属性：
> ```tsx
> delete store.propertyName;
> ```
> 请确认在组件中谨慎访问此属性，例如使用可选链接( ?. ):
> ```tsx
> const propertyValue = store.propertyName?.value;
> ```




### Methods

为了在 store 上提供方法，您必须将它们转换为 QRL，并使用 `this` 引用存储，如下所示：

```tsx
import { component$, useStore, $, type QRL } from "@builder.io/qwik";

type CountStore = { count: number; increment: QRL<(this: CountStore) => void> };

export default component$(() => {
  const state = useStore<CountStore>({
    count: 0,
    increment: $(function (this: CountStore) {
      this.count++;
    }),
  });

  return (
    <>
      <button onClick$={() => state.increment()}>Increment</button>
      <p>Count: {state.count}</p>
    </>
  );
});
```

> 你知道为什么应该在 `useStore()` 中使用常规的 `function(){}` 而不是箭头函数吗？这是因为在 javascript 中，[箭头函数没有自己的 `this` 绑定](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)。这意味着如果尝试使用箭头函数访问 `this`，`this.count` 可能指向另一个对象的 `count` 😱。

## 计算状态

在 Qwik 中，有两种创建计算值的方法，每种方法都有不同的用例（按优先顺序）：

1. `useComputed$()`: `useComputed$()` 是创建计算值的首选方法。当计算值可以纯粹从源状态（当前应用程序状态）同步派生时，请使用它。例如，创建字符串的小写版本或将名字和姓氏组合成全名。

2. [`useResource$()`](/docs/(qwik)/components/state/index.mdx#useresource): 当计算值是异步的或状态来自应用程序外部时，使用 `useResource$()`。例如，根据当前位置（应用程序内部状态）获取当前天气（外部状态）。

除了上面描述的两种创建计算值的方法之外，还有一种更低级别的方法（[`useTask$()`](/docs/(qwik)/components/tasks/index.mdx#usetask)）。这种方式不会产生新的信号，而是修改现有状态或产生副作用。

### `useComputed$()`

使用 `useComputed$()` 创建一个计算值，该值从其他状态同步派生。

它类似于其他框架中的 `memo`，因为它只会在输入信号之一发生更改时重新计算值。


<CodeSandbox src="/src/routes/demo/state/computed/index.tsx" style={{ height: '8em' }}>
```tsx {5} /useComputed$/
import { component$, useComputed$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const name = useSignal('Qwik');
  const capitalizedName = useComputed$(() => {
    // it will automatically reexecute when name.value changes
    return name.value.toUpperCase();
  });

  return (
    <>
      <input type="text" bind:value={name} />
      <p>Name: {name.value}</p>
      <p>Capitalized name: {capitalizedName.value}</p>
    </>
  );
});
```
</CodeSandbox>

> **注意** 由于 `useComputed$()` 是同步的，因此不需要显式跟踪输入信号。

### `useResource$()`

使用 `useResource$()` 创建一个异步派生的计算值。它是 `useComputed$()` 的异步版本，包括值之上的资源状态（加载中、已解析、已拒绝）。

`useResource$()` 的常见用法是在组件内部从外部 API 获取数据，这可能发生在服务器端或客户端。

`useResource$` 钩子是为 `<Resource />` 设计的。`<Resource />` 组件是根据资源状态渲染不同 UI 的一种便捷方式。

<CodeSandbox src="/src/routes/demo/state/resource/index.tsx" style={{ height: '8em' }}>
```tsx {11} /useResource$/
import {
  component$,
  Resource,
  useResource$,
  useSignal,
} from '@builder.io/qwik';

export default component$(() => {
  const prNumber = useSignal('3576');

  const prTitle = useResource$<string>(async ({ track }) => {
    // it will run first on mount (server), then re-run whenever prNumber changes (client)
    // this means this code will run on the server and the browser
    track(() => prNumber.value);
    const response = await fetch(
      `https://api.github.com/repos/QwikDev/qwik/pulls/${prNumber.value}`
    );
    const data = await response.json();
    return data.title as string;
  });

  return (
    <>
      <input type="number" bind:value={prNumber} />
      <h1>PR#{prNumber}:</h1>
      <Resource
        value={prTitle}
        onPending={() => <p>Loading...</p>}
        onResolved={(title) => <h2>{title}</h2>}
      />
    </>
  );
});
```
</CodeSandbox>



> **注意** 关于 `useResource$` 的重要事项是它在初始组件渲染时执行（就像 `useTask$` 一样）。通常情况下，希望在服务器上的初始 HTTP 请求中开始获取数据，以便在组件渲染之前。在服务器端渲染（SSR）期间获取数据是一种常见且首选的数据加载方法，通常由 [`routeLoader$`](/docs/(qwikcity)/route-loader/index.mdx) API 处理。`useResource$` 是一种更低级别的 API，当您想在浏览器中获取数据时非常有用。
>
>
> 很多方面 `useResource$` 与 `useTask$` 相似。主要区别是：
>
> - `useResource$` 允许您返回一个“值”。
> - `useResource$` 会在组件的初始渲染时运行，然后在资源状态更改时重新运行。
>
> 查阅 [`routeLoader$`](/docs/(qwikcity)/route-loader/index.mdx) 以获取数据的早期加载作为初始 HTTP 请求的一部分。

> **注意** 在 SSR 期间，`<Resource>` 组件将暂停渲染，直到资源解析。这样 SSR 将不会使用加载指示器渲染。

#### 高级示例

一个更完整的示例，使用 `AbortController`、`track` 和 `cleanup` 获取数据。这个示例将根据用户输入的查询获取笑话列表，自动响应查询的更改，包括中止当前正在进行的请求。

<CodeSandbox src="/src/routes/demo/state/resource-joke/index.tsx" style={{ height: '40em' }}>
```tsx {11} /useResource$/
import {
  component$,
  useResource$,
  Resource,
  useSignal,
} from '@builder.io/qwik';

export default component$(() => {
  const query = useSignal('busy');
  const jokes = useResource$<{ value: string }[]>(
    async ({ track, cleanup }) => {
      track(() => query.value);
      // A good practice is to use `AbortController` to abort the fetching of data if
      // new request comes in. We create a new `AbortController` and register a `cleanup`
      // function which is called when this function re-runs.
      const controller = new AbortController();
      cleanup(() => controller.abort());

      if (query.value.length < 3) {
        return [];
      }

      const url = new URL('https://api.chucknorris.io/jokes/search');
      url.searchParams.set('query', query.value);

      const resp = await fetch(url, { signal: controller.signal });
      const json = (await resp.json()) as { result: { value: string }[] };

      return json.result;
    }
  );

  return (
    <>
      <label>
        Query: <input bind:value={query} />
      </label>
      <button>search</button>
      <Resource
        value={jokes}
        onPending={() => <>loading...</>}
        onResolved={(jokes) => (
          <ul>
            {jokes.map((joke, i) => (
              <li key={i}>{joke.value}</li>
            ))}
          </ul>
        )}
      />
    </>
  );
});
```
</CodeSandbox>

正如我们在上面的示例中看到的，`useResource$()` 返回一个 `ResourceReturn<T>` 对象，它的工作方式类似于一个响应式 promise，包含数据和资源状态。

状态 `resource.loading` 可以是以下之一：

- `false` - 数据尚不可用。
- `true` - 数据可用。 (已解析或已拒绝。)

传递给 [`useResource$()`](/docs/(qwik)/components/state/index.mdx#useresource) 的回调在 [`useTask$()`](/docs/(qwik)/components/tasks/index.mdx#usetask) 回调完成后立即运行。有关更多详细信息，请参阅 [生命周期](../tasks/index.mdx#lifecycle) 部分。

#### `<Resource />`

`<Resource />` is a component meant to be used with the `useResource$()` that renders different content depending on if the resource is pending, resolved, or rejected.
`<Resource />` 是一个组件，用于与 `useResource$()` 一起使用，根据资源的状态（pending、resolved、rejected）渲染不同的内容。

```tsx
<Resource
  value={weatherResource}
  onPending={() => <div>Loading...</div>}
  onRejected={() => <div>Failed to load weather</div>}
  onResolved={(weather) => {
    return <div>Temperature: {weather.temp}</div>;
  }}
/>
```

值得注意的是，使用 useResource$() 时，不需要 <Resource />。这只是一种方便的方式来渲染资源状态。

这是一个更简单的示例，展示了如何使用 `useResource$` 来执行对 [agify.io](https://agify.io/) API 的 fetch 调用。这将根据用户输入的名称猜测一个人的年龄，并在用户输入名称时更新。


<CodeSandbox src="/src/routes/demo/state/resource-agify/index.tsx" style={{ height: '8em' }}>
```tsx {11} /useResource$/
import {
  component$,
  useSignal,
  useResource$,
  Resource,
} from '@builder.io/qwik';

export default component$(() => {
  const name = useSignal<string>();

  const ageResource = useResource$<{
    name: string;
    age: number;
    count: number;
  }>(async ({ track, cleanup }) => {
    track(() => name.value);
    const abortController = new AbortController();
    cleanup(() => abortController.abort('cleanup'));
    const res = await fetch(`https://api.agify.io?name=${name.value}`, {
      signal: abortController.signal,
    });
    return res.json();
  });

  return (
    <section>
      <div>
        <label>
          Enter your name, and I'll guess your age!
          <input onInput$={(ev, el) => (name.value = el.value)} />
        </label>
      </div>
      <Resource
        value={ageResource}
        onPending={() => <p>Loading...</p>}
        onRejected={() => <p>Failed to person data</p>}
        onResolved={(ageGuess) => {
          return (
            <p>
              {name.value && (
                <>
                  {ageGuess.name} {ageGuess.age} years
                </>
              )}
            </p>
          );
        }}
      />
    </section>
  );
});
```
</CodeSandbox>

## 传递状态

Qwik 的一个好特性是可以将状态传递给其他组件。这样，只有从存储中读取的组件会被重新渲染。

有两种方法可以将状态传递给其他组件：

1. 通过 props 明确地将状态传递给子组件，
2. 或者通过上下文隐式地传递状态。

### 使用 props

将状态传递给其他组件最简单的方式是通过 props 传递。

<CodeSandbox src="/src/routes/demo/state/passing-props/index.tsx" style={{ height: '6em' }}>
```tsx {9} /userData=/
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const userData = useStore({ count: 0 });
  return <Child userData={userData} />;
});

interface ChildProps {
  userData: { count: number };
}
export const Child = component$<ChildProps>(({ userData }) => {
  return (
    <>
      <button onClick$={() => userData.count++}>Increment</button>
      <p>Count: {userData.count}</p>
    </>
  );
});
```
</CodeSandbox>

### 使用上下文

上下文 API 是一种将状态传递给组件的方式，无需通过 props 传递（即：避免了 prop 钻取问题）。自动地，树中的所有后代组件都可以访问状态的引用，并对其进行读/写访问。

查看 [上下文 API](../context/index.mdx) 了解更多信息。

<CodeSandbox src="/src/routes/demo/state/passing-context/index.tsx" style={{ height: '6em' }}>
```tsx /userData/ /export const CTX = createContextId<{ count: number }>('stuff');/ /useContextProvider(CTX, userData);/ /const userData = useContext(CTX);/
import {
  component$,
  createContextId,
  useContext,
  useContextProvider,
  useStore,
} from '@builder.io/qwik';

// Declare a context ID
export const CTX = createContextId<{ count: number }>('stuff');

export default component$(() => {
  const userData = useStore({ count: 0 });

  // Provide the store to the context under the context ID
  useContextProvider(CTX, userData);

  return <Child />;
});

export const Child = component$(() => {
  const userData = useContext(CTX);
  return (
    <>
      <button onClick$={() => userData.count++}>Increment</button>
      <p>Count: {userData.count}</p>
    </>
  );
});
```
</CodeSandbox>

## `noSerialize()`

Qwik 明确要求所有应用程序状态始终是可序列化的。这是为了确保 Qwik 应用程序具有 [可恢复性](/docs/(qwik)/concepts/resumable/index.mdx) 特性。

有时，需要存储无法序列化的数据；`noSerialize()` 指示 Qwik 不要尝试序列化标记的值。 
例如，对于第三方库的引用，如 [Monaco 编辑器](https://microsoft.github.io/monaco-editor/)，将始终需要 `noSerialize()`，因为它不可序列化。

如果将值标记为不可序列化，则该值将不会在序列化事件（例如从 SSR 恢复应用程序时）中保留，此时该值将设置为 `undefined`，开发人员需要在客户端重新初始化该值。

<CodeSandbox src="/src/routes/demo/state/no-serialize/index.tsx" style={{ height: '8em' }}>
```tsx /noSerialize/
import {
  component$,
  useStore,
  useSignal,
  noSerialize,
  useVisibleTask$,
  type NoSerialize,
} from '@builder.io/qwik';
import type Monaco from './monaco';
import { monacoEditor } from './monaco';

export default component$(() => {
  const editorRef = useSignal<HTMLElement>();
  const store = useStore<{ monacoInstance: NoSerialize<Monaco> }>({
    monacoInstance: undefined,
  });

  useVisibleTask$(() => {
    const editor = monacoEditor.create(editorRef.value!, {
      value: 'Hello, world!',
    });
    // Monaco is not serializable, so we can't serialize it as part of SSR
    // We can however instantiate it on the client after the component is visible
    store.monacoInstance = noSerialize(editor);
  });
  return <div ref={editorRef}>loading...</div>;
});
```
</CodeSandbox>
