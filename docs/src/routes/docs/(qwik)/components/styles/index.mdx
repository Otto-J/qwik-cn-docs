---
title: 样式 | Components
contributors:
  - manucorporat
  - zanettin
  - cunzaizhuyi
  - manuelsanchez2
  - literalpie
  - forresst
  - DustinJSilk
  - saikatdas0790
  - LiKang6688
  - Craiqser
  - adamdbradley
  - the-r3aper7
  - mhevery
  - igorbabko
  - mrhoodz
  - tanftw
updated_at: '2023-09-19T17:37:26Z'
created_at: '2023-03-20T23:45:13Z'
---

# 样式

Qwik 不强制使用特定的样式方法，您可以使用任何您喜欢的方法来为您的 Qwik 应用程序添加样式，例如 CSS、CSS-in-JS、CSS 模块...

## CSS Modules

Qwik 支持 [CSS Modules](https://github.com/css-modules/css-modules) 开箱即用，这要归功于 [Vite](https://vitejs.dev/guide/features.html#css-modules)。

要使用 CSS 模块，只需创建一个 `.module.css` 文件。例如，`MyComponent.module.css` 并在您的组件中导入它。

```css /container/#a title="src/components/MyComponent/MyComponent.module.css"
.container {
  background-color: red;
}
```

然后，组件中导入 CSS Modules。

```tsx {2} /styles/ /container/#a title="src/components/MyComponent/MyComponent.tsx"
import { component$ } from '@builder.io/qwik';
import styles from './MyComponent.module.css';

export default component$(() => {
  return <div class={styles.container}>Hello world</div>;
});
```

请记住，Qwik 使用 `class` 而不是 `className` 来指定 CSS 类。

Qwik 也接受数组、对象或它们的组合来分配多个类：

```tsx title="src/components/MyComponent/MyComponent.tsx"
import { component$ } from '@builder.io/qwik';
import styles from './MyComponent.module.css';

export default component$((props) => {
  // Array syntax example
  return (
    <div
      class={[
        styles.container,
        'p-8',
        props.isHighAttention ? 'text-green-500' : 'text-slate-500',
        { active: true },
      ]}
    >
      Hello world
    </div>
  );

  // Object syntax example
  return (
    <div
      class={{
        'text-green-500': props.isHighAttention,
        'p-4': true,
      }}
    >
      Hello world
    </div>
  );
});
```

## 全局样式

许多应用程序使用全局样式表来重置浏览器并定义全局样式。这是一个好的实践，但不建议用它来为组件添加样式。Qwik 优化了让浏览器下载当前视图所需的样式。如果使用全局样式表，所有样式将在第一次加载时下载，即使它们不是当前视图所需的。

```tsx
import './global.css';
```

> 自动地，Qwik 会尝试在生产模式下将这个文件内联，如果 CSS 的大小小于 10KB。如果文件大于 10KB，它将作为一个单独的文件加载。

## CSS-in-JS

Qwik 对 CSS-in-JS 有着一流的支持，使用 [styled-vanilla-extract](https://github.com/wmertens/styled-vanilla-extract)

```tsx title="style.css.ts"
import { style } from 'styled-vanilla-extract/qwik';

export const blueClass = style({
  display: 'block',
  width: '100%',
  height: '500px',
  background: 'blue',
});
```

```tsx title="component.tsx"
import { component$ } from '@builder.io/qwik';
import { blueClass } from './styles.css';

export const Cmp = component$(() => {
  return <div class={blueClass} />;
});
```

```shell
npm run qwik add styled-vanilla-extract
```

请参考我们官方集成的文档了解更多信息。

> **那么 emotion 或其他 CSS-in-JS 库呢？** 尽管非常流行，但 emotion 和其他 CSS-in-JS 库并不是 Qwik 的最佳选择。[它们没有针对运行时性能进行优化，也没有良好的 SSR 流支持](https://dev.to/srmagura/why-were-breaking-up-wiht-css-in-js-4g9b)，导致服务器和客户端性能下降。

## Styled-components

styled-components 库是 React 生态中流行的 CSS-in-JS 编写工具。感谢同样的 [styled-vanilla-extract](https://github.com/wmertens/styled-vanilla-extract) 插件，你可以在 Qwik 中使用 styled-components 语法编写样式，且不会产生运行时成本！

```shell
npm run qwik add styled-vanilla-extract
```

Like this:

```tsx title="styles.css.ts"
import { styled } from 'styled-vanilla-extract/qwik';

export const BlueBox = styled.div`
  display: block;
  width: 100%;
  height: 500px;
  background: blue;
`;
```

```tsx title="component.tsx"
import { component$ } from '@builder.io/qwik';
import { BlueBox } from './styles.css';

export const Cmp = component$(() => {
  return <BlueBox />;
});
```

## Scoped CSS

要使用 scoped CSS，你可以使用从 `@builder.io/qwik` 导出的 `useStylesScoped$()` 钩子。

```tsx {4-8} title="src/components/MyComponent/MyComponent.tsx"
import { component$, useStylesScoped$ } from '@builder.io/qwik';

export default component$(() => {
  useStylesScoped$(`
    .container {
      background-color: red;
    }
  `);
  return <div class="container">Hello world</div>;
});
```

你也可以导入外部 CSS 文件。为此，你需要在导入 CSS 文件时添加 `?inline` 查询参数，并将 CSS 文件的默认导出传递给 `useStyleScoped$()` 钩子。

```css title="src/components/MyComponent/MyComponent.css"
.container {
  background-color: red;
}
```

```tsx {3,6} title="src/components/MyComponent/MyComponent.tsx"
import { component$, useStylesScoped$ } from '@builder.io/qwik';

import styles from './MyComponent.css?inline';

export default component$(() => {
  useStylesScoped$(styles);
  return <div class="container">Hello world</div>;
});
```

### `:global()` 选择器

使用 `useStylesScoped$` 会将规则集中的所有子选择器限定在组件内。如果你需要为通过 `<Slot />` 渲染的子组件设置样式，你将需要使用 `:global()` 选择器来跳出限定的样式。

```tsx
import { useStylesScoped$, component$ } from '@builder.io/qwik';

export const List = component$(() => {
  useStylesScoped$(`
    .list {
      display: flex;

      > :global(*nth-child(3)) {
        width: 100%
      }
    }
  `);

  return (
    <div class="list">
      <Slot />
    </div>;
  );
});
```

这将渲染一个 `.list.⭐️8vzca0-0 > *:nth-child(3)` 的 css 选择器，允许你定位子组件。这可以被认为是 Angular 中使用 `::ng-deep` 的等效方法。

> 注意，这可能会对你的组件树产生意想不到的影响。

## `useStyles$()`

组件样式的懒加载引用。

组件样式允许 Qwik 仅在需要时懒加载组件的样式信息，避免在 SSR 水合过程中的双重加载。

```tsx
import { useStyles$, component$ } from '@builder.io/qwik';
import styles from './code-block.css?inline';

export const CmpStyles = component$(() => {
  useStyles$(styles);
  return <span class="my-text">Some text</span>;
});
```

```css
// code-block.css
.my-text {
  color: red;
}
```

> 注意，为了在 Vite 中将 CSS 作为字符串导入，你需要添加 `?inline` 查询参数到导入中，像这样：`import styles from './code-block.css?inline';`

## CSS 预处理器

感谢 [Vite](https://vitejs.dev/guide/features.html#css-pre-processors)，Qwik 支持像 Sass、Less、Stylus 和 PostCSS 这样的 CSS 预处理器。

不需要安装 Qwik 特定的插件，但必须安装相应的预处理器本身：

```bash
# .scss and .sass
npm add -D sass

# .less
npm add -D less

# .styl and .stylus
npm add -D stylus
```

Check [Vite's docs](https://vitejs.dev/guide/features.html#css-pre-processors) for more information.

## Tailwind

要在你的应用中使用 Tailwind，你可以通过我们内置的集成添加它：

```shell
npm run qwik add tailwind
```

查看[集成文档](/docs/integrations/tailwind/index.mdx)了解更多信息。

## PostCSS

也可以在你的应用中通过我们内置的集成使用 PostCSS：

```shell
npm run qwik add postcss
```

重要提示：由于我们使用的是 vite，配置应如下所示才能工作：

```shell
// Configuration with vite
module.exports = {
  plugins: {
    autoprefixer: {},
    "postcss-preset-env": {
      stage: 3,
      features: {
        "nesting-rules": true,
      },
    },
  },
}
```

现在你将能够使用如下的嵌套规则 CSS：

```css
body {
  & .box {
    background: red;

    &:hover {
      background: yellow;
    }
  }
}
```

Check out [the integration docs](/docs/integrations/postcss/index.mdx) for more information.

## 为什么不使用 `<style>` 标签内联样式？

确保组件加载正确样式的一种简单方法是将样式信息内联到组件中，像这样。

```tsx
export const MyComponent = () => {
  return (
    <>
      <style>.my-class { color: red; }</style>
      My Component
    </>
  );
}
```

这种方法的问题是我们会加载样式两次。

1. 样式作为 SSR 的一部分被插入到 HTML 中。
2. 然后当组件失效并需要重新渲染时，样式会因为被内联而再次加载。

需要的是独立于组件加载样式。这就是 [`useStyles$()`](</docs/(qwik)/components/styles/index.mdx#usestyles>) 的用途。有两种情况：

1. 组件在服务器上渲染，样式作为 SSR 的一部分被插入到 `<head>` 中。
   - 向应用添加一个新的组件实例不需要我们加载样式，因为它们已经作为 SSR 的一部分被包含在内。
2. 组件首次在客户端渲染。在这种情况下，新组件在 `<head>` 中没有样式，因为该组件不是 SSR 的一部分。
   - 添加一个不是 SSR 一部分的新组件需要加载样式并将其插入到 `<head>` 中。
